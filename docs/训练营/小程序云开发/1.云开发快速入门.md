
如果你想免费、快速的开发出一个完整的项目，用小程序的云开发可能是最好的选择。小程序的云开发所用到的主要是前端开发的知识。

#### 注册微信小程序

小程序的注册非常方便，打开小程序注册页面，按照要求填入个人的信息，验证邮箱和手机号，扫描二维码绑定你的微信号即可，3分钟左右的时间即可搞定。

**注册页面：**[小程序注册页面](https://mp.weixin.qq.com/wxopen/waregister?action=step1)
> 注册小程序时不能使用注册过微信公众号、微信开放平台的邮箱哦，也就是需要你使用一个其他邮箱才行。
当我们注册成功后，就可以自动登入到小程序的后台管理页面啦，如果你不小心关掉了后台页面，也可以点击小程序后台管理登录页进行登录。

**后台管理页：**[小程序后台管理登录页](https://mp.weixin.qq.com/cgi-bin/home?t=home/index&amp;lang=zh_CN)
> 小程序和微信公众号的登录页都是同一个页面，他们会根据你的不同的注册邮箱来进行跳转。
进入到小程序的后台管理页后，点击左侧菜单的**开发**进入设置页，然后再点击**开发设置**，在**开发者ID**里就可以看到**AppID(小程序ID)**，这个待会我们有用。
> 注意小程序的ID（AppID）不是你注册的邮箱和用户名，你需要到后台查看才行哦~

#### 必备工具与云开发文档

大家可以根据自己的电脑操作系统来下载相应的版本，注意要选择稳定版 Stable Build的开发者工具。

**开发者工具**：[小程序开发者工具下载地址](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)

和学习任何编程一样，官方技术文档都是最值得阅读的参考资料。技术文档大家先只需要**<span style="color: #800000;">花五分钟左右的时间</span>**了解大致的结构即可，<span style="color: #800000;">**先按照我们的教学步骤学完之后**</span>再来看也不迟哦。

**技术文档：**[云开发官方文档](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)
> 由于小程序的云开发在不断新增功能，更新非常频繁，所以要确保自己的开发者工具是最新的哦（不然会报很多奇奇怪怪的错误），比如你之前下载过要先同步到最新才行~

#### 体验云开发模板小程序

安装完开发者工具之后，我们使用微信扫码登录开发者工具，然后使用开发者工具新建一个小程序的项目：

*   **项目名称**：这个可以根据自己的需要任意填写；
*   **目录**：大家可以先在电脑上新建一个空文件夹，然后选择它；
*   **AppID**：就是之前我们找到的**AppID(小程序ID)**（也可以下拉选择AppID）
*   **开发模式**为小程序（默认），
*   **后端服务**选择**小程序·云开发**
点击**新建**确认之后就能在开发者工具的**模拟器**里看到**云开发QuickStart小程序**，在编辑器里看到这个小程序的源代码。

接下来，我们点击开发者工具的工具栏里的**预览**图标，就会弹出一个二维码，使用微信扫描这个二维码就能在手机里看到这个小程序啦。
> 如果你没有使用微信登录开发者工具，以及你的微信不是该小程序的开发者是没法预览的哦。
在手机里（或模拟器）操作这个小程序，把小程序里的每个按键都点一遍，看看会有什么反应。我们会发现很多地方都会显示“调用失败”等，这非常正常，我们接下来会通过一系列的操作让小程序不报错。

#### 开通云开发服务

点击微信开发者工具的“**云开发**”图标，在弹出框里点击“**开通**”，同意协议后，会弹出**创建环境**的对话框。这时会要求你输入**环境名称**和**环境ID**，以及当前云开发的基础环境配额（基础配额免费，而且足够你使用哦）。
> 建议你**环境名称**可以使用`xly`、**环境ID**自动生成即可，当你的云开发环境出现问题的时候，你可以提供你的环境ID，云开发团队会有专人为你解答。
按照对话框提示的要求填写完之后，点击**创建**，会初始化环境，环境初始化成功后会自动弹出云开发控制台，这样我们的云开发服务就开通啦。大家可以花**两分钟左右**的时间熟悉一下云开发控制台的界面。

**找到云开发的环境ID**

点击云开发控制台窗口里的**设置**图标，在**环境变量**的标签页找到**环境名称**和**环境ID**。

当云开发服务开通后，我们可以在小程序源代码cloudfunctions文件夹名看到你的环境名称。如果在cloudfunctions文件夹名显示的不是环境名称，而是“**未指定环境**”，可以鼠标右键该文件夹，选择“更多设置”，然后再点击“设置”小图标，选择环境并确定。

**指定小程序的云开发环境**

在开发者工具中打开源代码文件夹**miniprogram**里的app.js，找到如下代码：
<pre class="lang:default decode:true">wx.cloud.init({
  // 此处请填入环境 ID, 环境 ID 可打开云控制台查看
  env: 'my-env-id',
  traceUser: true,
})</pre>
在`env: 'my-env-id'`处改成你的环境ID，如`env: 'xly-snoop'`

#### 下载Nodejs

**NodeJS**是在服务端运行JavaScript的运行环境，云开发所使用的服务端环境就是NodeJS。**npm**是Node包管理器，通过npm，我们可以非常方便的安装云开发所需要的依赖包。
> npm是前端开发必不可少的包（模块）管理器，它的主要功能就是来管理**包package**，包括安装、卸载、更新、查看、搜索、发布等，其他编程语言也有类似的包管理器，比如Python的pip，PHP的composer、Java的maven。我们可以把包管理器看成是windows的软件管理中心或手机的应用中心，只是它们用的是可视化界面，包管理器用的是**命令行Command Line**。
**下载地址：**[Nodejs下载地址](http://nodejs.cn/download/)

大家可以根据电脑的操作系统下载相应的NodeJS安装包并安装（<span style="color: #800000;">**安装时不要修改安装目录，啥也别管直接next安装即可**</span>）。打开电脑终端（Windows电脑为**cmd命令提示符**，Mac电脑为终**端Terminal**），然后逐行输入并按Enter执行下面的代码：
<pre class="lang:default decode:true">node --version
npm --version</pre>
如果显示为<span class="s1">v10.15.0以及</span><span class="s1">6.11.3（可能你的版本号会有所不同），表示你的Nodejs环境已经安装成功。</span>
> 学编程要仔细，一个字母，一个单词，一个标点符号都不要出错哦。注意输上面的命令时node、npm的后面有一个空格，而且是两个短横杠--。

#### 部署并上传云函数

**部署并上传云函数**

<span style="color: #800000;">**cloudfuntions文件夹**</span>图标里有朵小云，表示这就是**云函数根目录**。展开cloudfunctions，我们可以看到里面有login、openapi、callback、echo文件夹，这些就是**云函数目录**。而**miniprogram文件夹**则放置的是小程序的页面文件。
> cloudfunctions里放的是云函数，miniprogram放的是小程序的页面，这并不是一成不变的，也就是说你也可以修改这些文件夹的名称，这取决于项目配置文件project.config.json里的如下配置项：
> <pre class="lang:default decode:true">"miniprogramRoot": "miniprogram/",
> "cloudfunctionRoot": "cloudfunctions/",</pre>
> 但是你最好是让放小程序页面的文件夹以及放云函数的文件夹处于平级关系且都在项目的根目录下，便于管理。
使用鼠标右键其中的一个云函数目录比如login，在右键菜单中选择<span style="color: #800000;">**在终端中打开**</span>，打开后在终端中输入以下代码并按Enter回车执行：
<pre class="lang:default decode:true">npm install</pre>
> 如果显示“npm不是内部或外部命令”，你需要关闭微信开发者工具启动的终端，而是重新打开一个终端窗口，并在里面输入`cd /D 你的云函数目录`进入云函数目录，比如`cd /D C:\download\tcb-project\cloudfunctions\login`进入login的云函数目录，然后再来执行npm install命令。
这时候会下载云函数的依赖模块，下载完成后，再右键login云函数目录，点击“**创建并部署：所有文件**”，这时会把本地的云函数上传到云端，上传成功后在login云函数目录图标会变成一朵小云。

在开发者工具的工具栏上点击“**云开发**”图标会打开云开发控制台，在云开发控制台点击**云函数**图标，就能在云函数列表里看到我们上传好的“login”云函数啦。

接下来我们按照这样的流程把**其他所有云函数**（如openapi）都部署都上传，也就是要执行和上面相同的步骤，总结如下：

1.  右键云函数目录，选择在终端中打开，输入`npm install`命令下载依赖文件；
2.  然后再右键云函数目录，点击“**创建并部署：所有文件**”
3.  在云开发控制台--云函数--**云函数列表**查看云函数是否部署成功。

#### npm包管理器与依赖模块

为什么要在云函数目录执行npm install，而不是其他地方？这是因为npm install会下载云函数目录下的配置文件**package.json**里的**dependencies**，它表示的是当前云函数需要依赖的模块。package.json在哪里，就在哪里执行npm install，没有package.json，没有dependencies，就没法下载啊。

执行npm install命令下载的依赖模块会放在**node_modules**文件夹里，大家可以在执行了npm install命令之后，在电脑里打开查看一下**node_modules**文件夹里下载了哪些模块。

既然npm install是下载模块，那它是从哪里下载的呢？就以wx-server-sdk为例，我们可以在以下链接看到wx-server-sdk的情况：
<pre class="lang:xhtml decode:true">https://www.npmjs.com/package/wx-server-sdk</pre>
为什么package.json里依赖的是一个模块wx-server-sdk，但是node_modules文件夹里却下载了那么多模块？这是因为wx-server-sdk也依赖三个包tcb-admin-node、protobuf、jstslib，而这三个包又会依赖其他包，子子孙孙的，于是就有了很多模块。

node_modules文件夹这么大（几十M~几百M都可能），会不会影响小程序的大小？小程序的大小只与**<span style="color: #800000;">miniprogram文件夹</span>**有关，当你把云函数都部署上传到服务器之后，你把整个<span style="color: #800000;">**cloudfuntions文件夹**</span>删掉都没有关系。相同的依赖（比如都依赖wx-server-sdk）一旦部署到云函数之后，你可以选择不上传node_modules时，因为已经上传过了。

#### 获取openid与云函数login

当我们把**云函数login**部署上传成功后，就可以在模拟器以及手机（需要重新点击**预览**图标并扫描二维码）里**点击获取openid**了。

**点击获取openid**

openid是小程序用户的唯一标识，也就是每一个小程序用户都有一个唯一的openid。点击“**点击获取openid**”，在**用户管理指引**页面如果显示“用户id获取成功”以及一串字母+数字，那么表示你login云函数部署并上传成功啦。<span style="color: #800000;">**如果获取openid失败，你则需要解决login云函数的部署上传，才能进行下面的步骤哦**</span>。

**调用云函数的解读**

小程序的首页是"pages/index/index"，我们可以从app.json的配置项或者模拟器左下角的页面路径可以看出来。在index.wxml里有这段代码：
<pre class="lang:xhtml decode:true ">&lt;button class="userinfo-nickname" bindtap="onGetOpenid"&gt;点击获取 openid&lt;/button&gt;</pre>
也就是当点击“**点击获取openid**”按钮时，会触发bindtap绑定的事件处理函数**onGetOpenid**，在index.js里可以看到onGetOpenid事件处理函数（<span style="color: #800000;">**在index.js里找到事件处理函数onGetOpenid对比理解**</span>）调用了wx.cloud.callFunction()接口（<span style="color: #800000;">**打开技术文档对比理解**</span>）

**技术文档：**[调用云函数wx.cloud.callFunction](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/functions/callFunction.html)

调用云函数的方法很简单，只需要填写云函数的名称name（这里为login），以及需要传递的参数（这里并没有上传参数），就可以进行调用。在success回调函数里添加以下代码<span style="color: #800000;">**打印res对象**</span>：
<pre class="lang:js decode:true ">console.log('调用login云函数返回的res',res)</pre>
> 添加完成之后<span style="color: #800000;">**记得保存代码**</span>哦，文件修改没有保存会在标签页有一个小的绿点。可以使用快捷键（同时按）Ctrl和S来保存（Mac电脑为Command和S）。
编译之后，再点击“**点击获取openid**”按钮，就能看到完整的res对象，res对象有三个参数：

*   **requestID**：云函数执行 ID，可用于在**云开发控制台**查找日志，打开云开发控制台--云函数--日志，可以在这里根据云函数函数名以及requestID来筛选查看云函数的调用日志（含返回结果）；
*   **result：**<span style="color: #800000;">**云函数返回的结果**</span>，login云函数返回的结果里包含appid、event对象，我们可以通过res.result.appid以及res.result.event访问它们；
*   errMsg：显示云函数是否调用成功
事件处理函数onGetOpenid调用云函数成功之后，干了三件事情：

*   使用console.log打印openid，可以在点击按钮触发云函数在控制台看到该打印结果；
*   把获取到的appid赋值给app.js文件里的globalData全局对象；
*   跳转到userConsole页面；
而userConsole页面就只是从globalData里将openid取出来通过setData渲染到页面。
> **小任务：**你明白为啥wx.cloud.callFunction()是小程序端的API了么？思考一下为啥云开发会有小程序端的API和服务端API的区别？能理解多少是多少，不清楚也没有关系，后面会有更多内容助你理解。
**云函数login解读**

为什么调用云函数login返回的res的**result对象**里会包含event对象、appid、userInfo这些结果？这就取决于云函数是怎么写的了。使用开发者工具打开**login云函数**（在**cloudfuntions文件夹**里）的index.js。
<pre class="lang:js decode:true ">exports.main = (event, context) =&gt; {}</pre>
这是一个**箭头函数**的写法，其中**event**和**context**是参数。我们将两个打印日志修改为以下代码，相当于备注一下到底打印到哪里去了：
<pre class="lang:js decode:true ">console.log('服务端打印的event',event)
console.log('服务端打印的context',context)</pre>
保存之后，右键点击index.js文件，选择**云函数增量上传:（更新文件）**，更新login云函数，我们再来点击“**点击获取openid**”按钮，打印的结果在哪里呢？在**云开发控制台的云函数日志里面**。我们发现event对象包含程序用户的 openid 和小程序的 appid，而context对象则是云函数的调用信息和运行状态。
> 云函数的打印日志会显示云开发控制台的日志里面，这一点非常重要，要多加利用。只要是打印日志，无论是显示在开发者工具控制台还是显示在云开发控制台的就没有不重要的。
<div>
<div>**getWXContext()**</div>
</div>
getWXContext()API是云开发服务端的工具类API，会返回小程序用户的openid、小程序appid、小程序用户的unionid等。说这么多不如直接打印，在下面添加一行打印信息：
<pre class="lang:js decode:true ">const wxContext = cloud.getWXContext()
console.log('getWXContext返回的结果',wxContext)</pre>
保存之后，右键点击index.js文件，选择**云函数增量上传:（更新文件）**，更新login云函数，我们再来点击“**点击获取openid**”按钮，然后去云开发控制台的云函数日志里看到底返回了什么结果。

**技术文档：**[getWXContext()](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-server-api/utils/getWXContext.html)

对照技术文档来理解返回的结果。
> 注意小程序用户 unionid只有在开发者帐号下存在**同主体的**公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用才能获得。
**return**

return语句是终止函数的执行，并返回一个指定的值给**函数调用者**。这里返回了4个值，而前面我们就调用过login云函数，就是**函数的调用者**，所以我们打印的事件处理函数onGetOpenid的回调函数的**res对象**正是这个return返回的结果。那既然如此，我们在return多加一些内容看看，比如我们之前的一些数据结构案例，将return函数改为如下代码：
<pre class="lang:js decode:true ">  let lesson = "云开发技术训练营";
  let enname = "CloudBase Camp";
  let x = 3, y = 4, z = 5.001, a = -3, b = -4, c = -5;
  let now = new Date();
  return {
    movie: { name: "霸王别姬", img: "https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1910813120.webp", desc: "风华绝代。" },
    movielist:["肖申克的救赎", "霸王别姬", "这个杀手不太冷", "阿甘正传", "美丽人生"],
    charat: lesson.charAt(4),
    concat: enname.concat(lesson),
    uppercase: enname.toUpperCase(),
    abs: Math.abs(b),
    pow: Math.pow(x, y),
    sign: Math.sign(a),
    now: now.toString(),
    fullyear: now.getFullYear(),
    date: now.getDate(),
    day: now.getDay(),
    hours: now.getHours(),
    minutes: now.getMinutes(),
    seconds: now.getSeconds(),
    time: now.getTime(),
    event,
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,
  }</pre>
保存之后，右键点击index.js文件，选择**云函数增量上传:（更新文件）**，更新login云函数，我们再来点击“**点击获取openid**”按钮，然后去云开发控制台的云函数日志里看到底返回了什么结果。
> 这里我们多次反复提及更新了index.js文件之后就要选择**云函数增量上传:（更新文件）**，更新login云函数，希望大家平时的时候注意，这也是小程序云开发**服务端**和**小程序端**一个非常大的区别。

#### 新建云函数

鼠标右键cloudfunctions云函数根目录，在弹出的窗口选择**新建Node.js云函数**，比如输入**sum**，按Enter确认后，微信开发者工具会在本地（你的电脑）创建出**sum云函数目录**，同时也会在线上环境中创建出对应的云函数（也就是自动部署好了，可以到云开发控制台云函数列表里看到）

打开sum云函数目录下的index.js，添加 <span id="crayon-5d73987b92a36114172053" class="crayon-syntax crayon-syntax-inline crayon-theme-monokai crayon-theme-monokai-inline crayon-font-monaco"><span class="crayon-pre crayon-code"><span class="crayon-v">sum</span><span class="crayon-o">:</span><span class="crayon-v">event</span><span class="crayon-sy">.</span><span class="crayon-v">a</span><span class="crayon-o">+</span><span class="crayon-v">event</span><span class="crayon-sy">.</span><span class="crayon-v">b</span><span class="crayon-sy">,</span></span></span>到return函数里（把多余的内容可以删掉了），然后<span style="color: #800000;">**记得选择云函数增量上传:（更新文件），更新sum云函数**</span>。
<pre class="lang:js decode:true"> return {
    sum:event.a+event.b,
  }</pre>
这个a和b是变量，但是和前面不一样的是，在服务端我们并没有声明a和b啊，这是因为我们可以在小程序端声明变量。

点击开发者工具模拟器的“**快速新建云函数**”，会跳转到addFunction页面，打开addFunction.wxml，我们看到**测试云函数**绑定的是testFunction事件处理函数。
<pre class="lang:xhtml decode:true ">&lt;view class="list-item" bindtap="testFunction"&gt;
   &lt;text&gt;测试云函数&lt;/text&gt;
&lt;/view&gt;</pre>
我们去看addFunction.js里的testFunction，看变量a和b这两个小程序端的变量是怎么和服务端的变量关联起来的，而又是如何把结果渲染到页面的。testFunction调用云函数sum同样是通过wx.cloud.callFunction，不同的是在data里有a和b：
<pre class="lang:js decode:true ">data: {
  a: 1,
  b: 2
},</pre>
data里填写的是传递给云函数的参数，也就是先把小程序端的参数传递给云函数，然后云函数处理之后再返回res对象，我们可以在success回调函数里打印res对象：
<pre class="lang:js decode:true">console.log("sum云函数返回的对象",res)</pre>
编译之后，我们再点击**测试云函数**，在控制台就能看到打印的结果，res.result.sum就是3。直接把res.result.sum通过setData赋值到result就能渲染出数字，那这个res.result是什么？JSON.stringify()又是什么？
<pre class="lang:js decode:true">result: JSON.stringify(res.result)</pre>
我们可以打印一下res.result，以及JSON.stringify(res.result)
<pre class="lang:js decode:true">console.log("res.result是啥", res.result)
console.log("JSON.stringify(res.result)是啥", JSON.stringify(res.result))</pre>
res.result是对象，而JSON.stringify(res.result)是json格式，`JSON.stringify()` 方法是将一个JavaScript值(对象或者数组)转换为一个 **JSON字符串**，因为对象如果直接渲染到页面是会显示`[object Object]`的。
> **小任务：**将小程序的参数传递给云端，有没有一点wx.request的感觉？相当于我们通过云函数写好了一个数据API，然后在小程序端调用。新建一个云函数，把各种数学运算都部署到云端，然后通过传递参数，调用这些算法，并将结果渲染到页面。

#### 上传图片

使用模拟器或手机端点击**云开发QuickStart小程序**的上传图片按钮，选择一张图片并打开，如果在**文件存储指引**页面显示上传成功和文件的路径以及图片的缩略图，说明你的图片就上传到云开发服务器里啦。

点击云开发控制台的**存储**图标，就可以进入到**存储管理页**查看到你之前上传的图片啦，点击该图片名称可以看到这张图片的一些信息，如：文件大小、格式、上传者的OpenID以及**存储位置**、**下载地址**和**File ID**。复制下载地址链接，在浏览器就能查看到这张图片啦。
> 值得注意的是由于QuickStart小程序将“上传图片”这个按钮上传的所有图片都命名为my-image，所以上传同一格式的图片就会被覆盖掉，也就是无论你上传多少张相同格式的图片，只会在后台里看到最后更新的那张图片。以后我们会教大家怎么修改代码，让图片不会被覆盖。

#### 体验云调用

重新点击开发者工具的**预览**图标，然后用手机扫描二维码，在**手机端**点击云开发QuickStart的云调用，就可以发送模板消息和获取小程序码。
> 发送模板消息，只能在手机微信里预览测试哦，使用微信开发者工具是发送不了模板消息的哦
点击**发送模板消息**，你的微信就会收到一则服务通知，该通知是由你的小程序发出的**购买成功**通知。这就是微信的模板消息啦，很多微信公众号、小程序都会有这样的功能，使用小程序云开发，我们也可以轻松定制自己的服务通知（以后会教大家如何定制）。

点击**获取小程序码**，如果显示调用失败，说明你的**openapi云函数**没有部署成功，需要你先部署成功才行哦。调用成功，就能获取到你的小程序码啦，这个小程序码也会保存到云开发的存储里。

#### 前端操作数据库

点击微信开发者工具的云开发图标，打开云开发控制台，点击数据库图标进入到**数据库管理页**，点击**集合名称**右侧的**+号**图标，就可以创建一个数据集合了。

在开发者工具的编辑器里展开**miniprogram文件夹**，打开pages文件下databaseGuide里的**databaseGuide.js**文件，在这里找到`onAdd: function (){}`、`onQuery: function (){}`、`onCounterInc: function (){}`、`onCounterDec: function (){}`、`onRemove: function (){}`分别选中绿色的代码块，然后**同时按**快捷键Ctrl和/（Mac电脑的快捷键为Command和/），就可以批量取消代码的注释。
> //是前端编程语言JavaScript的单行注释，位于 <span class="code_marked">//</span> 这一行的代码都不会执行，我们使用快捷键就是批量取消这些代码的注释，让整段代码生效。之所以显示为绿色，是微信开发者工具为了让我们看得更清晰而做的语法高亮。
<div>
<div>**前端操作数据库的页面逻辑**</div>
</div>
以上的函数是在小程序的前端页面来操作数据库，点击开发者工具模拟器云开发QuickStart里的前端操作数据库，

*   在第1步（数据库指引有标注），我们会获取到用户的openid，也就是说没有获取到openid是没法通过小程序的前端来操作数据库的哦
*   第2步，需要我们在**云开发控制台**里的**数据库管理页**创建一个**counters**的集合（不需添加数据）；
*   第3步，点击按钮页面的按钮“**新增记录**”（按钮就在这个页面的第4条与第5条之间，看起来不是那么明显），这时会调用`onAdd`方法，往**counters集合**新增一个记录（之前手动添加有木有很辛苦？），我们可以去云开发控制台的**数据库管理页**查看一下counters集合是不是有了一条记录；大家可以多点击几下**新增记录**按钮，看数据库又有什么变化。也就是小程序前端页面通过`onAdd`方法，在数据库新增了记录。
*   第4步，点击按钮**查询记录**，这时调用的是`onQuery`方法就能在小程序里**获取到**第3步我们存储到数据库里的数据啦
*   第5步，点击计数器按钮+号和-号，可以更新count的值，点击+号按钮会调用`onCounterInc`方法，而点击-号`onCounterDec`方法，比如我们点击加号到7，再去**数据库管理页**查看最新的一条记录（也就是最后一条），它的count由原来的1更新到了7（**先点刷新按钮**），我们再点击-号按钮到5，再来数据库管理页查看有什么变化变化（**先点刷新按钮**）
*   第6步，点击**删除记录**按钮，会调用`onRemove`方法，这时会删掉数据库里最新的记录（也就是第5步里的那一条记录）。
通过实战我们了解到，databaseGuide.js文件里的`onAdd`、`onQuery`、`onCounterInc`、`onCounterDec`、`onRemove`可以实现小程序的前端页面来操作数据库。

这些函数大家可以结合**databaseGuide.js**文件和**云开发技术文档**关于数据库的内容来理解。

*   `onAdd`：在集合中新增记录的[Collection.add](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/collection.add.html)
*   `onQuery`：获取根据查询条件筛选后的集合数据[Query.get](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/collection.get.html)
*   `onCounterInc`、`onCounterDec`：更新集合记录的[Document.update](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/doc.update.html)
*   `onRemove`：删除集合记录的[Document.remove](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/doc.remove.html)
> 结合实战案例**通过查阅技术文档的方式**来理解函数的逻辑，这是学编程非常重要的学习方法。所有编程语言都会涉及到非常多的函数、模块、库等等，这些不是教材或者技术博文所能概括的，而技术文档相当于收录这些函数的词典，多翻阅技术文档有助于我们的技术进阶。
关于云函数是如何上传图片、进行云调用、操作数据库，这个我们会在后面的章节来详细讲解。